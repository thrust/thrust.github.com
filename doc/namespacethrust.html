<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>thrust: thrust Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">thrust</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">thrust Namespace Reference</div>  </div>
</div>
<div class="contents">

<p><code>thrust</code> is the top-level namespace which contains all Thrust functions and types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1cpp.html">cpp</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><code><a class="el" href="namespacethrust_1_1cpp.html" title="thrust::cpp is a top-level alias for thrust::system::cpp.">thrust::cpp</a></code> is a top-level alias for <a class="el" href="namespacethrust_1_1system_1_1cpp.html" title="thrust::system::cpp is the namespace containing functionality for allocating, manipulating, and deallocating memory available to Thrust&#39;s standard C++ backend system. The identifiers are provided in a separate namespace underneath thrust::system for import convenience but are also aliased in the top-level thrust::cpp namespace for easy access.">thrust::system::cpp</a>. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1cuda.html">cuda</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><code><a class="el" href="namespacethrust_1_1cuda.html" title="thrust::cuda is a top-level alias for thrust::system::cuda.">thrust::cuda</a></code> is a top-level alias for <a class="el" href="namespacethrust_1_1system_1_1cuda.html" title="thrust::system::cuda is the namespace containing functionality for allocating, manipulating, and deallocating memory available to Thrust&#39;s CUDA backend system. The identifiers are provided in a separate namespace underneath thrust::system for import convenience but are also aliased in the top-level thrust::tbb namespace for easy access.">thrust::system::cuda</a>. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1omp.html">omp</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><code><a class="el" href="namespacethrust_1_1omp.html" title="thrust::omp is a top-level alias for thrust::system::omp.">thrust::omp</a></code> is a top-level alias for <a class="el" href="namespacethrust_1_1system_1_1omp.html" title="thrust::system::omp is the namespace containing functionality for allocating, manipulating, and deallocating memory available to Thrust&#39;s OpenMP backend system. The identifiers are provided in a separate namespace underneath thrust::system for import convenience but are also aliased in the top-level thrust::omp namespace for easy access.">thrust::system::omp</a>. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1random.html">random</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><code><a class="el" href="namespacethrust_1_1random.html" title="thrust::random is the namespace which contains random number engine class templates, random number engine adaptor class templates, engines with predefined parameters, and random number distribution class templates. They are provided in a separate namespace for import convenience but are also aliased in the top-level thrust namespace for easy access.">thrust::random</a></code> is the namespace which contains random number engine class templates, random number engine adaptor class templates, engines with predefined parameters, and random number distribution class templates. They are provided in a separate namespace for import convenience but are also aliased in the top-level <code>thrust</code> namespace for easy access. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1system.html">system</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><code><a class="el" href="namespacethrust_1_1system.html" title="thrust::system is the namespace which contains functionality for manipulating memory specific to one ...">thrust::system</a></code> is the namespace which contains functionality for manipulating memory specific to one of Thrust's backend systems. It also contains functionality for reporting error conditions originating from the operating system or other low-level application program interfaces such as the CUDA runtime. They are provided in a separate namespace for import convenience but are also aliased in the top-level <code>thrust</code> namespace for easy access. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacethrust_1_1tbb.html">tbb</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p><code><a class="el" href="namespacethrust_1_1tbb.html" title="thrust::tbb is a top-level alias for thrust::system::tbb.">thrust::tbb</a></code> is a top-level alias for <a class="el" href="namespacethrust_1_1system_1_1tbb.html" title="thrust::system::tbb is the namespace containing functionality for allocating, manipulating, and deallocating memory available to Thrust&#39;s TBB backend system. The identifiers are provided in a separate namespace underneath thrust::system for import convenience but are also aliased in the top-level thrust::tbb namespace for easy access.">thrust::system::tbb</a>. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__allocator_3_01void_01_4.html">device_allocator&lt; void &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__allocator.html">device_allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__malloc__allocator.html">device_malloc_allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__new__allocator.html">device_new_allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__reference.html">device_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1unary__function.html">unary_function</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1binary__function.html">binary_function</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1plus.html">plus</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1minus.html">minus</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1multiplies.html">multiplies</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1divides.html">divides</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1modulus.html">modulus</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1negate.html">negate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1equal__to.html">equal_to</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1not__equal__to.html">not_equal_to</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1greater.html">greater</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1less.html">less</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1greater__equal.html">greater_equal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1less__equal.html">less_equal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1logical__and.html">logical_and</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1logical__or.html">logical_or</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1logical__not.html">logical_not</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1bit__and.html">bit_and</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1bit__or.html">bit_or</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1bit__xor.html">bit_xor</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1identity.html">identity</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1maximum.html">maximum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1minimum.html">minimum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1project1st.html">project1st</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1project2nd.html">project2nd</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1unary__negate.html">unary_negate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1binary__negate.html">binary_negate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1host__vector.html">host_vector</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1constant__iterator.html">constant_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1counting__iterator.html">counting_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1discard__iterator.html">discard_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1input__device__iterator__tag.html">input_device_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1output__device__iterator__tag.html">output_device_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1forward__device__iterator__tag.html">forward_device_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1bidirectional__device__iterator__tag.html">bidirectional_device_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1random__access__device__iterator__tag.html">random_access_device_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1iterator__traits.html">iterator_traits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1iterator__space.html">iterator_space</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1permutation__iterator.html">permutation_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1transform__iterator.html">transform_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1zip__iterator.html">zip_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1pointer.html">pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1reference.html">reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1pair.html">pair</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1tuple__element.html">tuple_element</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthrust_1_1tuple__size.html">tuple_size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthrust_1_1tuple.html">tuple</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::input_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#ga9c81b5a0793b7ab5164138cf90bc4467">input_host_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::output_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#ga1a68f19231a55966d6ccbbeb0143fc78">output_host_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::forward_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#ga3e917ce7912b40457dc8bf8eac3f63c4">forward_host_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
std::bidirectional_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#ga4fc4cba5e02678c694d1e2c38ecc97ac">bidirectional_host_iterator_tag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
std::random_access_iterator_tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iterator__tag__classes.html#ga80a4b8250e3322344767a6b417e72256">random_access_host_iterator_tag</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga7a4ecc0deca6892ee7ed8676a62a9e0a">adjacent_difference</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga02e643b9418679ab0aac88651965f781">adjacent_difference</a> (InputIterator first, InputIterator last, OutputIterator result, BinaryFunction binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Distance &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterators.html#ga6c459f10ce81b84c1143496b8da299f4">advance</a> (InputIterator &amp;i, Distance n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class LessThanComparable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__binary__search.html#gad93c05b26512b028756d2371eda1c433">lower_bound</a> (ForwardIterator first, ForwardIterator last, const LessThanComparable &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T , class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__binary__search.html#ga1859b9a37c183977d71be0ad53828b41">lower_bound</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class LessThanComparable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__binary__search.html#ga6cb19db84268caf2906dbe6652b7f160">upper_bound</a> (ForwardIterator first, ForwardIterator last, const LessThanComparable &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T , class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__binary__search.html#ga1a1ce27e4c2cc6bbd80a978bcaf9e8da">upper_bound</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class LessThanComparable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__binary__search.html#ga644377fc6809b206e5cf2ea7960132f6">binary_search</a> (ForwardIterator first, ForwardIterator last, const LessThanComparable &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T , class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__binary__search.html#ga559e1125528e5fe58d4ab64834805201">binary_search</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class LessThanComparable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; ForwardIterator, <br class="typebreak"/>
ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__binary__search.html#ga05a747f5d23ae803b3dba6c9d4be3ab8">equal_range</a> (ForwardIterator first, ForwardIterator last, const LessThanComparable &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T , class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; ForwardIterator, <br class="typebreak"/>
ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__binary__search.html#ga78c0bafe9611566e620edd474007bb64">equal_range</a> (ForwardIterator first, ForwardIterator last, const T &amp;value, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class InputIterator , class OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vectorized__binary__search.html#ga4716b6d1c6c2d351185ea191b00be9cf">lower_bound</a> (ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class InputIterator , class OutputIterator , class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vectorized__binary__search.html#gae931ccab1888b496a5d53fa06f016df5">lower_bound</a> (ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator output, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class InputIterator , class OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vectorized__binary__search.html#gab0381e0c2c8a3ba1b7fa2b691443e551">upper_bound</a> (ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class InputIterator , class OutputIterator , class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vectorized__binary__search.html#gae8580c9f45671c81eed9cd3d87fa8c79">upper_bound</a> (ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator output, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class InputIterator , class OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vectorized__binary__search.html#ga0b96283885f30a6900e491fde9078c07">binary_search</a> (ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class InputIterator , class OutputIterator , class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__vectorized__binary__search.html#ga6023ed9acd56e9f03c81818ad493ca6e">binary_search</a> (ForwardIterator first, ForwardIterator last, InputIterator values_first, InputIterator values_last, OutputIterator output, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__copying.html#ga6e123c4508ed48ce98e79f4679c1aac2">copy</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Size , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__copying.html#ga2fad03147f5025a70be41bf89408c2b3">copy_n</a> (InputIterator first, Size n, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga59ae90883860b391cec33e13e73fece3">copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gab6f762b3382ab3a5bcb891394f8a818b">copy_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class EqualityComparable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1iterator__traits.html">thrust::iterator_traits</a><br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__counting.html#gaed7430565cd9d714515b659075964de1">count</a> (InputIterator first, InputIterator last, const EqualityComparable &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1iterator__traits.html">thrust::iterator_traits</a><br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__counting.html#ga3726ca0c8fb6becc2c5a6744414859fe">count_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__deallocation__functions.html#ga219d29c235cef1377c487a08c9217fc4">device_delete</a> (<a class="el" href="classthrust_1_1device__ptr.html">thrust::device_ptr</a>&lt; T &gt; ptr, const size_t n=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__deallocation__functions.html#ga1a350740a6ade432f3781096df91f162">device_free</a> (<a class="el" href="classthrust_1_1device__ptr.html">thrust::device_ptr</a>&lt; void &gt; ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1device__ptr.html">thrust::device_ptr</a>&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#ga53081c2b134f091a080c976a1cbaf8cd">device_malloc</a> (const std::size_t n)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#ga4c8a057314da6f7dab0b471f5b726247">device_new</a> (<a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; void &gt; p, const size_t n=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#ga0fa58b4eeeb26187d60af1d68bfc2e8e">device_new</a> (<a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; void &gt; p, const T &amp;exemplar, const size_t n=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__allocation__functions.html#gafcea8c22c0b3e98bd4567ec65b96dfc3">device_new</a> (const size_t n=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class E , class T , class Y &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; E, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#ga901cb64f4bfc3cce0d217e741c45fdc4">operator&lt;&lt;</a> (std::basic_ostream&lt; E, T &gt; &amp;os, const <a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; Y &gt; &amp;p)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#gae76e0501378683b1484d9797e8c327c6">device_pointer_cast</a> (T *ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#ga33a97359089a2dc3b7f42b38ddfba2b3">device_pointer_cast</a> (const <a class="el" href="classthrust_1_1device__ptr.html">device_ptr</a>&lt; T &gt; &amp;ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__classes.html#ga1e9ad356b6a974cb58f3f890ebb67bb0">swap</a> (<a class="el" href="classthrust_1_1device__reference.html">device_reference</a>&lt; T &gt; &amp;x, <a class="el" href="classthrust_1_1device__reference.html">device_reference</a>&lt; T &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1iterator__traits.html">thrust::iterator_traits</a><br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterators.html#ga7aca72a5d6db68ff8d58407f57ebfd5b">distance</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparisons.html#ga3282d7cca489b11517873c1b632add6e">equal</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__comparisons.html#ga02e74f1fc5f8f9e88cf8c7aa38f45dab">equal</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T min&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust.html#a5e32fb36c1ebca7db20e097e115b0780">THRUST_PREVENT_MACRO_SUBSTITUTION</a> (const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ T min&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust.html#a390794e3b4ade1670aa14ecc00a18c84">THRUST_PREVENT_MACRO_SUBSTITUTION</a> (const T &amp;lhs, const T &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#ga1062ee9c61ace34b724e141f85e79999">min_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#ga1fa9b9c2deff94b0b251b0c74bddf878">min_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#ga06e155dabb91848ffd1c5725f8e0ce14">max_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#ga15bc459d66e289d99a789b99594f7339">max_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; ForwardIterator, <br class="typebreak"/>
ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#ga2eca879afc4b66d3e868254b923ea9a6">minmax_element</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; ForwardIterator, <br class="typebreak"/>
ForwardIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__extrema.html#ga677abc58735384da218141a106649198">minmax_element</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filling.html#gac8bd6f546d43f61fcbcacd789103448d">fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename Size , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filling.html#ga35266b2f61d05be97497fc3250559bb8">fill_n</a> (OutputIterator first, Size n, const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__searching.html#gad3a9c4432d4ad6daef6517b678bf7cf8">find</a> (InputIterator first, InputIterator last, const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__searching.html#ga7d90491ec231a41753f74a973c15417d">find_if</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__searching.html#gaf1f926cbef7508655474f17208b480d9">find_if_not</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modifying.html#ga7fc567dd60f9733214f5c6797ce36b53">for_each</a> (InputIterator first, InputIterator last, UnaryFunction f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Size , typename UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">InputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__modifying.html#ga4b02f08a7509216cb1493c670ad3ce9d">for_each_n</a> (InputIterator first, Size n, UnaryFunction f)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1unary__negate.html">unary_negate</a>&lt; Predicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__function__object__adaptors.html#ga6ef6af79f55a23e8fd404ab9bb216a33">not1</a> (const Predicate &amp;pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="structthrust_1_1binary__negate.html">binary_negate</a>&lt; BinaryPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__function__object__adaptors.html#ga3d0fd8ff20edb02401130c5851850a3c">not2</a> (const BinaryPredicate &amp;pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename RandomAccessIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gathering.html#ga323223ecfa02d17428921d8c2de2ff2d">gather</a> (InputIterator map_first, InputIterator map_last, RandomAccessIterator input_first, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename RandomAccessIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gathering.html#gad76bc3a94927009af4eea8b64e9a2bc8">gather_if</a> (InputIterator1 map_first, InputIterator1 map_last, InputIterator2 stencil, RandomAccessIterator input_first, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename RandomAccessIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__gathering.html#gafcbf36174987d80237bad50b4ac99339">gather_if</a> (InputIterator1 map_first, InputIterator1 map_last, InputIterator2 stencil, RandomAccessIterator input_first, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Generator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#gad5f3c63fe57a75d03a731d0cd824e3e2">generate</a> (ForwardIterator first, ForwardIterator last, Generator gen)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename Size , typename Generator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga847c3c767b22003420ed5bc9c85b6947">generate_n</a> (OutputIterator first, Size n, Generator gen)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#gaff95eb23b4fb99f7a873c1471c0a75c6">inner_product</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType , typename BinaryFunction1 , typename BinaryFunction2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#ga8fcc4e5a71e784f1f32af89ab5a42e35">inner_product</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputType init, BinaryFunction1 binary_op1, BinaryFunction2 binary_op2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename V , typename I &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="classthrust_1_1constant__iterator.html">constant_iterator</a>&lt; V, I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fancyiterator.html#ga615a7458d9f31595bacce5d720c3f4be">make_constant_iterator</a> (V x, I i=int())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="classthrust_1_1constant__iterator.html">constant_iterator</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fancyiterator.html#gabff03c09d3bc09548006c72add3c027e">make_constant_iterator</a> (V x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Incrementable &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="classthrust_1_1counting__iterator.html">counting_iterator</a><br class="typebreak"/>
&lt; Incrementable &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fancyiterator.html#ga2621be4fff70d312f68fab6753ae583e">make_counting_iterator</a> (Incrementable x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="classthrust_1_1discard__iterator.html">discard_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fancyiterator.html#ga9c95ea281f5a4a0e3c4ff345baaa3a16">make_discard_iterator</a> (<a class="el" href="classthrust_1_1discard__iterator.html">discard_iterator</a>&lt;&gt;::difference_type i=<a class="el" href="classthrust_1_1discard__iterator.html">discard_iterator</a>&lt;&gt;::difference_type(0))</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ElementIterator , typename IndexIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="classthrust_1_1permutation__iterator.html">permutation_iterator</a><br class="typebreak"/>
&lt; ElementIterator, <br class="typebreak"/>
IndexIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fancyiterator.html#ga8d2b419d0dd31e117dc3fb96a66fe82a">make_permutation_iterator</a> (ElementIterator e, IndexIterator i)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename BidirectionalIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a><br class="typebreak"/>
&lt; BidirectionalIterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fancyiterator.html#gaea605114c89ac48286cb767ee8e1bbcc">make_reverse_iterator</a> (BidirectionalIterator x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class AdaptableUnaryFunction , class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="classthrust_1_1transform__iterator.html">transform_iterator</a><br class="typebreak"/>
&lt; AdaptableUnaryFunction, <br class="typebreak"/>
Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fancyiterator.html#gabbf9e2d8caf9408dc371cefff9090c3a">make_transform_iterator</a> (Iterator it, AdaptableUnaryFunction fun)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename IteratorTuple &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
<a class="el" href="classthrust_1_1zip__iterator.html">zip_iterator</a>&lt; IteratorTuple &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__fancyiterator.html#ga3a68093f82072d1375ca8b921b550f1e">make_zip_iterator</a> (IteratorTuple t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical.html#ga0d56ac3e3645fe5d00556a8ff6cb90d2">all_of</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical.html#ga563be0bd879ce60f6894b92af224a9c5">any_of</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__logical.html#ga8cf87f8dbf0a5a3008b0f39cd9c91292">none_of</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
thrust::detail::pointer_traits<br class="typebreak"/>
&lt; Pointer &gt;::raw_pointer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#ga7d29bd29c9901e2ee9f0aa23e8c2137a">raw_pointer_cast</a> (const Pointer &amp;ptr)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
detail::raw_reference&lt; T &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#gacba47eb8c0d06c54039b60972f64acb9">raw_reference_cast</a> (T &amp;ref)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
detail::raw_reference&lt; const T &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory__management__functions.html#gaa54e6b19eb6c966f48dec960cb771d83">raw_reference_cast</a> (const T &amp;ref)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#ga91d42e699631de9f7647090c91eadf7a">merge</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__merging.html#ga08e5daa16d8a6c10d657be37b48c69a3">merge</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; InputIterator1, <br class="typebreak"/>
InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__searching.html#ga033a49b8477195cd863a0f1e3e93de72">mismatch</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; InputIterator1, <br class="typebreak"/>
InputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__searching.html#ga1e6ee5e823fc87ded3e82fee1c73be35">mismatch</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#ga07fa347dad05f7f98e988190b9f494c1">operator==</a> (const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#ga1313f3d40d7eadda53d8cf9ef3000d09">operator&lt;</a> (const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#gaaf84453a4a2fac003719a7b75ed73089">operator!=</a> (const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#gaf9185c57c198b82d1804e7108b024cab">operator&gt;</a> (const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#ga0901b7b10d9b808a8a49ff541e3fb842">operator&lt;=</a> (const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#gaf8f1e44d863b80acae9141a7c8526e0f">operator&gt;=</a> (const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#ga604aff7b85e9d04828c34cdb74ee04a6">swap</a> (<a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="structthrust_1_1pair.html">pair</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#ga026b4d321773e98358783c4a3dcc046a">make_pair</a> (T1 x, T2 y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__partitioning.html#ga0c4bd59a85f63ec0d17f579e92fc333e">partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator1 , typename OutputIterator2 , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__partitioning.html#ga9bdf30b32dedc158f0f6576bfa407917">partition_copy</a> (InputIterator first, InputIterator last, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__partitioning.html#ga3ad7415db9a024743c30950a62345656">stable_partition</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator1 , typename OutputIterator2 , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__partitioning.html#ga8c2066c5739578b8d880f7bce723e2eb">stable_partition_copy</a> (InputIterator first, InputIterator last, OutputIterator1 out_true, OutputIterator2 out_false, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__searching.html#ga1b61bfe7c810941e02b723e050c805ba">partition_point</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga89fcfdee91be8f435e68b5172a002329">is_partitioned</a> (InputIterator first, InputIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1iterator__traits.html">thrust::iterator_traits</a><br class="typebreak"/>
&lt; InputIterator &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#gacf5a4b246454d2aa0d91cda1bb93d0c2">reduce</a> (InputIterator first, InputIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#ga4e625915bd37ea94d2fdf7cd9637f350">reduce</a> (InputIterator first, InputIterator last, T init)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T , typename BinaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#ga268b8b31c9c3a2e6e4b3b6be1f5c202d">reduce</a> (InputIterator first, InputIterator last, T init, BinaryFunction binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#gac1fadcdd29791f655a3144c2e741838a">reduce_by_key</a> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#gaad7b4e06163c4a34e3cc4e07ef8647ab">reduce_by_key</a> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate , typename BinaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__reductions.html#gae8a56ee466f4fe53d237aa1dde2b7488">reduce_by_key</a> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gaee39ef07b42f5d17b453e409f7f9b315">remove</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gae94994f9049c44a4298dcf2c6ceb2514">remove_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga517b17ceafe31a9fc70ac5127bd626de">remove_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga0dd1a702821e89b3369c7ae0d3f45af7">remove_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename InputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga5760a32d1a99d89732206f48b75138ea">remove_if</a> (ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga0779d9d2b8a76305ca853bb1a70c7c52">remove_copy_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#ga82185290785dc3e4d090e6ac4a9a6a98">replace</a> (ForwardIterator first, ForwardIterator last, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Predicate , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#ga3c90447007bf72cd99168d1f99c6794d">replace_if</a> (ForwardIterator first, ForwardIterator last, Predicate pred, const T &amp;new_value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename InputIterator , typename Predicate , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#gaf471914d5e928de1f2b52df5e0bbf7b7">replace_if</a> (ForwardIterator first, ForwardIterator last, InputIterator stencil, Predicate pred, const T &amp;new_value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#ga4a70cf0046bce92d6ba8b255ad724aec">replace_copy</a> (InputIterator first, InputIterator last, OutputIterator result, const T &amp;old_value, const T &amp;new_value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#gaaec29c3fdecb51cb8af5399fd2e86927">replace_copy_if</a> (InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__replacing.html#ga517f03a30b63d8934f143dfedb437a9e">replace_copy_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, OutputIterator result, Predicate pred, const T &amp;new_value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename BidirectionalIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust.html#a076e8291a8d5a1748cc4623b8c758c93">reverse</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename BidirectionalIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacethrust.html#a74cc5ae45b2ef03a07ce9d28f68818ca">reverse_copy</a> (BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga2b01071da974e996c0ccbe89e5d2d7ce">inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename AssociativeOperator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#gaf0da164f74833b02c1ba2ff88fc27439">inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, AssociativeOperator binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#gadb94a5315b0fdf69fc4f90b0e361ac85">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga2263c15d26b9861dc98603fdaef47095">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, T init)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T , typename AssociativeOperator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prefixsums.html#ga31786e0cf8d2dc957390ca092f300fa6">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, T init, AssociativeOperator binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga9e464dc32ccff03b66e7d810634c9a26">inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga3bccd2038b9f2a46d8908e085fbb5dc6">inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename AssociativeOperator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga05d4b099d9afea2762777bf85a3316de">inclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, AssociativeOperator binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga73ac77aacdcc81847c088827b9e85ccf">exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga057e88bffbaef810bceed8d24644941b">exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga80fedeb60b3990df6429a869fb840fe8">exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename AssociativeOperator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__segmentedprefixsums.html#ga36951c72c1a4a646fbe3ccdb1e94473b">exclusive_scan_by_key</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, AssociativeOperator binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename RandomAccessIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__scattering.html#gabb4ac574e2d294dcc86e9b2bf673a5bc">scatter</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, RandomAccessIterator output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename RandomAccessIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__scattering.html#ga1079bc05bcb3d4b5080f1e07444fee37">scatter_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename RandomAccessIterator , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__scattering.html#ga327f4705e6874c2b35a3f5b4be33d6f9">scatter_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 map, InputIterator3 stencil, RandomAccessIterator output, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga9cd45aa1d54c460639a56a02bc519a6c">sequence</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#gaca02e6edc478b671a21553ee4ca74390">sequence</a> (ForwardIterator first, ForwardIterator last, T init)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga6a0f1bee86020ea06e3a278956955041">sequence</a> (ForwardIterator first, ForwardIterator last, T init, T step)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga37985609f9f0671d45249d1d42c259ce">set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gacebdd5b8f408e403613b242b86406b07">set_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga17277fec1491c8a916c9908a5ae40807">set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga235d1ad5eae1b81be5830322cd33ccbe">set_intersection</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga2a6e7275fd83a3079804d143542c7b17">set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gaba42e4ea1667cb817cffb2310073078b">set_symmetric_difference</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#ga7fb6690a07e030091851eeff23a2f93a">set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename StrictWeakCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__set__operations.html#gadff01587848d3a8110bf71c59ed75635">set_union</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, StrictWeakCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sorting.html#ga8fd4df95e8e16c89ff92737947daa1f9">sort</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sorting.html#ga3d4da007a8ae4fb2d5b1c4d5a28a6cdb">sort</a> (RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sorting.html#ga6a7930fcd6bbd0ede72c4cf10f19b75e">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sorting.html#gaf4beb502c75e1dead41b5a7ada46dc5c">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sorting.html#ga5674c04d54eafefb130941d387db46e8">sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sorting.html#gae3829160fc6160d083f79a34e67bd452">sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sorting.html#gab41312f8cd7a71811a182ff40d589877">stable_sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__sorting.html#gaa2ea0dbec67dd1f91e09a42b3575c657">stable_sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#gadb8e5879d64546addb3b252c214e3bea">is_sorted</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#gaacb2a9c0e9b538c3f27da3c584c2749e">is_sorted</a> (ForwardIterator first, ForwardIterator last, Compare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga80259afb38e4ffa00cc074bf7f339ccc">is_sorted_until</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Compare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__predicates.html#ga3ad0512c0c8e25cd00835de58083bab1">is_sorted_until</a> (ForwardIterator first, ForwardIterator last, Compare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Assignable1 , typename Assignable2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__swap.html#ga0b13767b0d315633fd0e169028a80003">swap</a> (Assignable1 &amp;a, Assignable2 &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator1 , typename ForwardIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__copying.html#ga926a4031b491e798a1dec97e47130eac">swap_ranges</a> (ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga8dfab5757fde90225f5157ded26fc972">transform</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#gaa1a7f2a2a6b01891e5ca6b6380409cf8">transform</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ForwardIterator , typename UnaryFunction , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga2f16352f3298510df1646add454db3cf">transform_if</a> (InputIterator first, InputIterator last, ForwardIterator result, UnaryFunction op, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename ForwardIterator , typename UnaryFunction , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga0c6d919392b64d22d96ac31a51797c58">transform_if</a> (InputIterator1 first, InputIterator1 last, InputIterator2 stencil, ForwardIterator result, UnaryFunction op, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename ForwardIterator , typename BinaryFunction , typename Predicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformations.html#ga2b07e614bfd70cf8dee15b9a1f0f9e8c">transform_if</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator3 stencil, ForwardIterator result, BinaryFunction binary_op, Predicate pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFunction , typename OutputType , typename BinaryFunction &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__reductions.html#ga087a5af8cb83647590c75ee5e990ef66">transform_reduce</a> (InputIterator first, InputIterator last, UnaryFunction unary_op, OutputType init, BinaryFunction binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction , typename AssociativeOperator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__prefixsums.html#gad624fd82c14ece05343cb8e224c1075a">transform_inclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, AssociativeOperator binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction , typename T , typename AssociativeOperator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__transformed__prefixsums.html#ga5d3e99663670227589761cf36685b7ff">transform_exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, T init, AssociativeOperator binary_op)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int N, class HT , class TT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
access_traits&lt; typename <br class="typebreak"/>
<a class="el" href="structthrust_1_1tuple__element.html">tuple_element</a>&lt; N, detail::cons<br class="typebreak"/>
&lt; HT, TT &gt; &gt;::type &gt;<br class="typebreak"/>
::non_const_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple.html#ga4512fb8e91a457663ce15cb72b5ccd9e">get</a> (detail::cons&lt; HT, TT &gt; &amp;t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;int N, class HT , class TT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
access_traits&lt; typename <br class="typebreak"/>
<a class="el" href="structthrust_1_1tuple__element.html">tuple_element</a>&lt; N, detail::cons<br class="typebreak"/>
&lt; HT, TT &gt; &gt;::type &gt;<br class="typebreak"/>
::const_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple.html#ga915a1de5d5a0faa379985ca9a2adc4b6">get</a> (const detail::cons&lt; HT, TT &gt; &amp;t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
detail::make_tuple_mapper&lt; T0 &gt;<br class="typebreak"/>
::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple.html#gacadf6be17cd395d79302ec93b7ea11fc">make_tuple</a> (const T0 &amp;t0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T0 , class T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <br class="typebreak"/>
detail::make_tuple_mapper&lt; T0, <br class="typebreak"/>
T1 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple.html#gacf485e2c89cd1736daef7123b8e5bdc6">make_tuple</a> (const T0 &amp;t0, const T1 &amp;t1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="classthrust_1_1tuple.html">tuple</a>&lt; T0 &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple.html#ga6278476a3765d4a44ff996d1531770d4">tie</a> (T0 &amp;t0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ <a class="el" href="classthrust_1_1tuple.html">tuple</a>&lt; T0 <br class="typebreak"/>
&amp;, T1 &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple.html#gae8df9f2ec164819f8118f317fc284b60">tie</a> (T0 &amp;t0, T1 &amp;t1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8 , typename T9 , typename U0 , typename U1 , typename U2 , typename U3 , typename U4 , typename U5 , typename U6 , typename U7 , typename U8 , typename U9 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">__host__ __device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple.html#ga4319e9295fd41920b2794264c2c3fcb7">swap</a> (<a class="el" href="classthrust_1_1tuple.html">tuple</a>&lt; T0, T1, T2, T3, T4, T5, T6, T7, T8, T9 &gt; &amp;x, <a class="el" href="classthrust_1_1tuple.html">tuple</a>&lt; U0, U1, U2, U3, U4, U5, U6, U7, U8, U9 &gt; &amp;y)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__copying.html#gab4cbaf418d3e7c83f5f21781ef28b2ef">uninitialized_copy</a> (InputIterator first, InputIterator last, ForwardIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Size , typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__copying.html#ga2d18765c6629a10e669e884315d6c931">uninitialized_copy_n</a> (InputIterator first, Size n, ForwardIterator result)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filling.html#ga88a213cd2dd7ceabd528ceb99bbe953b">uninitialized_fill</a> (ForwardIterator first, ForwardIterator last, const T &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Size , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__filling.html#gadb60646fd055bb07669f5529721d0d6e">uninitialized_fill_n</a> (ForwardIterator first, Size n, const T &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga330c12555aa9d382254c9f1296e3edcc">unique</a> (ForwardIterator first, ForwardIterator last)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gaa213c713ba882275d7f98564528bc4ab">unique</a> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gae039017ffdee9a60fcb23e6c378ef0d6">unique_copy</a> (InputIterator first, InputIterator last, OutputIterator output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga59a7948ed24d06d3848d5ae3a087f062">unique_copy</a> (InputIterator first, InputIterator last, OutputIterator output, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator1 , typename ForwardIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; ForwardIterator1, <br class="typebreak"/>
ForwardIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga58de173e7dffb56eec2aecf3c533559f">unique_by_key</a> (ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator1 , typename ForwardIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; ForwardIterator1, <br class="typebreak"/>
ForwardIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gadc7b26c12fa96f449f17d7c1da3e24bd">unique_by_key</a> (ForwardIterator1 keys_first, ForwardIterator1 keys_last, ForwardIterator2 values_first, BinaryPredicate binary_pred)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#gaac7ed61a13a6c19ba636263fac91131d">unique_by_key_copy</a> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structthrust_1_1pair.html">thrust::pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stream__compaction.html#ga361958a1440786235d2561b66db5de57">unique_by_key_copy</a> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unspecified_iterator_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator__tags.html#ga55d3b8fbce6228591e85f18bb0ec18b4">reinterpret_tag</a> (Iterator iter)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">unspecified_iterator_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__iterator__tags.html#gac86669bb482a74c079860c0d28cac709">retag</a> (Iterator iter)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><code>thrust</code> is the top-level namespace which contains all Thrust functions and types. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a076e8291a8d5a1748cc4623b8c758c93"></a><!-- doxytag: member="thrust::reverse" ref="a076e8291a8d5a1748cc4623b8c758c93" args="(BidirectionalIterator first, BidirectionalIterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void thrust::reverse </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>reverse</code> reverses a range. That is: for every <code>i</code> such that <code>0 &lt;= i &lt;= (last - first) / 2</code>, it exchanges <code>*(first + i)</code> and <code>*(last - (i + 1))</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to reverse. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to reverse.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">BidirectionalIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">Bidirectional Iterator</a> and <code>BidirectionalIterator</code> is mutable.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>reverse</code> to reverse a <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> of integers.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="reverse_8h.html" title="Reverses the order of a range.">thrust/reverse.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> data[N] = {0, 1, 2, 3, 4, 5};
  <a class="code" href="classthrust_1_1device__vector.html">thrust::device_vector&lt;int&gt;</a> v(data, data + N);
  <a class="code" href="namespacethrust.html#a076e8291a8d5a1748cc4623b8c758c93">thrust::reverse</a>(v.begin(), v.end());
  <span class="comment">// v is now {5, 4, 3, 2, 1, 0}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/reverse.html">http://www.sgi.com/tech/stl/reverse.html</a> </dd>
<dd>
<code><a class="el" href="namespacethrust.html#a74cc5ae45b2ef03a07ce9d28f68818ca">reverse_copy</a></code> </dd>
<dd>
<code><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a74cc5ae45b2ef03a07ce9d28f68818ca"></a><!-- doxytag: member="thrust::reverse_copy" ref="a74cc5ae45b2ef03a07ce9d28f68818ca" args="(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BidirectionalIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator thrust::reverse_copy </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><code>reverse_copy</code> differs from <a class="el" href="namespacethrust.html#a076e8291a8d5a1748cc4623b8c758c93">reverse</a> only in that the reversed range is written to a different output range, rather than inplace.</p>
<p><code>reverse_copy</code> copies elements from the range <code>[first, last)</code> to the range <code>[result, result + (last - first))</code>such that the copy is a reverse of the original range. Specifically: for every <code>i</code> such that <code>0 &lt;= i &lt; (last - first)</code>, <code>reverse_copy</code> performs the assignment <code>*(result + (last - first) - i) = *(first + i)</code>.</p>
<p>The return value is <code>result + (last - first))</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The beginning of the range to reverse. </td></tr>
    <tr><td class="paramname">last</td><td>The end of the range to reverse. </td></tr>
    <tr><td class="paramname">result</td><td>The beginning of the output range.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">BidirectionalIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BidirectionalIterator.html">Bidirectional Iterator</a>, and <code>BidirectionalIterator's</code> <code>value_type</code> is convertible to <code>OutputIterator's</code> <code>value_type</code>. </td></tr>
    <tr><td class="paramname">OutputIterator</td><td>is a model of <a href="http://www.sgi.com/tech/stl/OutputIterator.html">Output Iterator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>reverse_copy</code> to reverse an input <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code> of integers to an output <code><a class="el" href="classthrust_1_1device__vector.html">device_vector</a></code>.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="reverse_8h.html" title="Reverses the order of a range.">thrust/reverse.h</a>&gt;</span>
  ...
  <span class="keyword">const</span> <span class="keywordtype">int</span> N = 6;
  <span class="keywordtype">int</span> data[N] = {0, 1, 2, 3, 4, 5};
  <a class="code" href="classthrust_1_1device__vector.html">thrust::device_vector&lt;int&gt;</a> input(data, data + N);
  <a class="code" href="classthrust_1_1device__vector.html">thrust::device_vector&lt;int&gt;</a> output(N);
  <a class="code" href="namespacethrust.html#a74cc5ae45b2ef03a07ce9d28f68818ca">thrust::reverse_copy</a>(v.begin(), v.end(), output.begin());
  <span class="comment">// input is still {0, 1, 2, 3, 4, 5}</span>
  <span class="comment">// output is now  {5, 4, 3, 2, 1, 0}</span>
</pre></div><dl class="see"><dt><b>See also:</b></dt><dd><a href="http://www.sgi.com/tech/stl/reverse_copy.html">http://www.sgi.com/tech/stl/reverse_copy.html</a> </dd>
<dd>
<code><a class="el" href="namespacethrust.html#a076e8291a8d5a1748cc4623b8c758c93">reverse</a></code> </dd>
<dd>
<code><a class="el" href="classthrust_1_1reverse__iterator.html">reverse_iterator</a></code> </dd></dl>

</div>
</div>
<a class="anchor" id="a5e32fb36c1ebca7db20e097e115b0780"></a><!-- doxytag: member="thrust::THRUST_PREVENT_MACRO_SUBSTITUTION" ref="a5e32fb36c1ebca7db20e097e115b0780" args="(const T &amp;lhs, const T &amp;rhs, BinaryPredicate comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T max thrust::THRUST_PREVENT_MACRO_SUBSTITUTION </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicate&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This version of <code>min</code> returns the smaller of two values, given a comparison operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first value to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second value to compare. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparison operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The smaller element.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>is convertible to <code>BinaryPredicate's</code> first argument type and to its second argument type. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">BinaryPredicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>min</code> to compute the smaller of two key-value objects.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="extrema_8h.html" title="Functions for computing computing extremal values.">thrust/extrema.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>key_value
  {
    <span class="keywordtype">int</span> key;
    <span class="keywordtype">int</span> value;
  };

  <span class="keyword">struct </span>compare_key_value
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(key_value lhs, key_value rhs)
    {
      <span class="keywordflow">return</span> lhs.key &lt; rhs.key;
    }
  };

  ...
  key_value a = {13, 0};
  key_value b = { 7, 1);

  key_value smaller = thrust::min(a, b, compare_key_value());

  <span class="comment">// smaller is {7, 1}</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Returns the first argument when the arguments are equivalent. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>max</dd></dl>
<p>This version of <code>max</code> returns the larger of two values, given a comparison operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first value to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second value to compare. </td></tr>
    <tr><td class="paramname">comp</td><td>A comparison operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The larger element.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>is convertible to <code>BinaryPredicate's</code> first argument type and to its second argument type. </td></tr>
    <tr><td class="paramname">BinaryPredicate</td><td>is a model of <a href="http://www.sgi.com/tech/stl/BinaryPredicate.html">BinaryPredicate</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>max</code> to compute the larger of two key-value objects.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="extrema_8h.html" title="Functions for computing computing extremal values.">thrust/extrema.h</a>&gt;</span>
  ...
  <span class="keyword">struct </span>key_value
  {
    <span class="keywordtype">int</span> key;
    <span class="keywordtype">int</span> value;
  };

  <span class="keyword">struct </span>compare_key_value
  {
    __host__ __device__
    <span class="keywordtype">bool</span> operator()(key_value lhs, key_value rhs)
    {
      <span class="keywordflow">return</span> lhs.key &lt; rhs.key;
    }
  };

  ...
  key_value a = {13, 0};
  key_value b = { 7, 1);

  key_value larger = thrust::max(a, b, compare_key_value());

  <span class="comment">// larger is {13, 0}</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Returns the first argument when the arguments are equivalent. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>min </dd></dl>

<p>Referenced by <a class="el" href="classthrust_1_1device__new__allocator.html#ae031e74dd4b7ca95a012773767228955">thrust::device_new_allocator&lt; T &gt;::max_size()</a>.</p>

</div>
</div>
<a class="anchor" id="a390794e3b4ade1670aa14ecc00a18c84"></a><!-- doxytag: member="thrust::THRUST_PREVENT_MACRO_SUBSTITUTION" ref="a390794e3b4ade1670aa14ecc00a18c84" args="(const T &amp;lhs, const T &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">__host__ __device__ T max thrust::THRUST_PREVENT_MACRO_SUBSTITUTION </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This version of <code>min</code> returns the smaller of two values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first value to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The smaller element.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">LessThan Comparable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>min</code> to compute the smaller of two integers.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="extrema_8h.html" title="Functions for computing computing extremal values.">thrust/extrema.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> a = 13;
  <span class="keywordtype">int</span> b = 7;

  <span class="keywordtype">int</span> smaller = thrust::min(a, b);

  <span class="comment">// smaller is 7</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Returns the first argument when the arguments are equivalent. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>max</dd></dl>
<p>This version of <code>max</code> returns the larger of two values. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The first value to compare. </td></tr>
    <tr><td class="paramname">rhs</td><td>The second value to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The larger element.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>is a model of <a href="http://www.sgi.com/tech/stl/LessThanComparable.html">LessThan Comparable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>The following code snippet demonstrates how to use <code>max</code> to compute the larger of two integers.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="extrema_8h.html" title="Functions for computing computing extremal values.">thrust/extrema.h</a>&gt;</span>
  ...
  <span class="keywordtype">int</span> a = 13;
  <span class="keywordtype">int</span> b = 7;

  <span class="keywordtype">int</span> larger = thrust::min(a, b);

  <span class="comment">// larger is 13</span>
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Returns the first argument when the arguments are equivalent. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>min </dd></dl>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon May 7 2012 15:15:01 for thrust by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
